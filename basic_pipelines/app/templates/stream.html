{% extends "base.html" %}

{% block title %}Stream - WetTheCat{% endblock %}

{% block content %}
<div class="container stream-page">
      <h2>LIVE</h2>
      <video id="video" controls autoplay muted></video>

      <!-- Bouton pour changer le mode -->
      <button id="mode-button" class="mode-button" style="background-color: red;">   
      </button>
      <div class="checkbox-container" style="margin-top: 20px;">
            <h3>Track Objects</h3>
            <label>
                  <input type="checkbox" id="cat-checkbox" value="cat" />
                  cat
            </label>
            <label>
                  <input type="checkbox" id="person-checkbox" value="person" />
                  person
            </label>
            <button id="save-objects-btn" style="margin-left: 15px;">Save Objects</button>
      </div>
</div>

<!-- Inclure hls.js depuis un CDN -->
<script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
<script>
      const video = document.getElementById('video');
      const videoSrc = "{{ stream_url }}";
      const modeButton = document.getElementById('mode-button');
      const catCheckbox = document.getElementById('cat-checkbox');
      const personCheckbox = document.getElementById('person-checkbox');
      const saveObjectsBtn = document.getElementById('save-objects-btn');

      // Couleurs associées aux différents modes (0, 1, 2)
      const modeColors = ['#ec6152', '#52ec97', '#5271ec'];

      // Fonction pour récupérer le mode sur le serveur
      function fetchMode() {
            return fetch('/camera_mode')
                  .then(response => response.json())
                  .then(data => {
                        return data.mode;
                  });
      }

      // Fonction pour mettre à jour le mode sur le serveur
      function updateMode(newMode) {
            return fetch('/camera_mode', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ mode: newMode })
            })
                  .then(response => response.json())
                  .then(data => {
                        return data.mode;
                  });
      }

      // Mettre la couleur du bouton en fonction du mode
      function setButtonColor(modeValue) {
            const index = modeValue % 3; // 0, 1 ou 2
            modeButton.style.backgroundColor = modeColors[index];
      }

      // Récupération initiale du mode au chargement de la page
      fetchMode()
            .then(mode => {
                  setButtonColor(mode);
            })
            .catch(err => console.error(err));

      // Vérifier régulièrement si le mode a changé ailleurs
      setInterval(() => {
            fetchMode()
                  .then(mode => {
                        setButtonColor(mode);
                  })
                  .catch(err => console.error(err));
      }, 5000);  // toutes les 5 secondes

      // Gérer le clic sur le bouton
      modeButton.addEventListener('click', () => {
            fetchMode()
                  .then(mode => {
                        // Incrémente le mode (0 -> 1 -> 2 -> 0)
                        let newMode = (mode + 1) % 3;
                        return updateMode(newMode);
                  })
                  .then(updatedMode => {
                        setButtonColor(updatedMode);
                  })
                  .catch(err => console.error(err));
      });

      // ----- PARTIE 2 : Gestion de track_objects -----

      // 2.1) Récupérer la liste track_objects existante
      function fetchTrackObjects() {
            return fetch('/track_objects')
                  .then(response => response.json())
                  .then(data => data.track_objects || []);
      }

      // 2.2) Mettre à jour la liste track_objects sur le serveur
      function updateTrackObjects(objectsList) {
            return fetch('/track_objects', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ track_objects: objectsList })
            })
                  .then(r => r.json());
      }

      // 2.3) Initialiser l'état des checkboxes selon la config
      fetchTrackObjects()
            .then(trackObjects => {
                  catCheckbox.checked = trackObjects.includes('cat');
                  personCheckbox.checked = trackObjects.includes('person');
            })
            .catch(err => console.error(err));

      // 2.4) Au clic sur "Save Objects", on envoie la liste cochée
      saveObjectsBtn.addEventListener('click', () => {
            const newList = [];
            if (catCheckbox.checked) newList.push('cat');
            if (personCheckbox.checked) newList.push('person');

            updateTrackObjects(newList)
                  .then(data => {
                        console.log('track_objects mis à jour:', data.track_objects);
                  })
                  .catch(err => console.error(err));
      });
      // Configuration du streaming HLS
      if (Hls.isSupported()) {
            const hls = new Hls();
            hls.loadSource(videoSrc);
            hls.attachMedia(video);
            hls.on(Hls.Events.MANIFEST_PARSED, function () {
                  video.play();
            });
      } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
            video.src = videoSrc;
            video.addEventListener('loadedmetadata', function () {
                  video.play();
            });
      }
</script>
{% endblock %}