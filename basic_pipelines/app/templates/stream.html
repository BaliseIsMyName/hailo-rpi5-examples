{% extends "base.html" %}

{% block title %}Stream - WetTheCat{% endblock %}

{% block content %}
<div class="container stream-page">
      <h2>LIVE</h2>
      <video id="video" controls autoplay muted></video>

      <!-- Bouton pour changer le mode -->
      <button id="mode-button" class="mode-button" style="background-color: red;">
      </button>
      <div class="checkbox-container" id="track-objects-container" style="margin-top: 20px;">
            <h3>Track Objects</h3>
            <!-- Les checkboxes seront générées dynamiquement ici -->
      </div>
</div>

<!-- Inclure hls.js depuis un CDN -->
<script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
<script>
      const video = document.getElementById('video');
      const videoSrc = "{{ stream_url }}";
      const modeButton = document.getElementById('mode-button');
      const trackObjectsContainer = document.getElementById('track-objects-container');

      // Couleurs associées aux différents modes (0, 1, 2)
      const modeColors = ['#ec6152', '#52ec97', '#5271ec'];

      let currentMode = 0; // Valeur par défaut, sera mise à jour dès le chargement

      // Stockage local des track_objects_list et track_objects pour détecter les changements
      let currentTrackObjectsList = [];
      let currentTrackObjects = [];

      // WebSocket pour les mises à jour de mode et de track_objects
      let socket = null;

      function initializeWebSocket() {
            // Établir la connexion WebSocket sécurisée
            socket = new WebSocket(`wss://${window.location.host}/ws/mode`);

            socket.onopen = function (event) {
                  console.log('WebSocket connecté pour les mises à jour.');
            };

            socket.onmessage = function (event) {
                  try {
                        const message = JSON.parse(event.data);
                        const type = message.type;
                        const data = message.data;

                        if (type === 'mode') {
                              if (data.mode !== undefined) {
                                    console.log('Mise à jour du mode reçue via WebSocket:', data.mode);
                                    currentMode = data.mode; // Mettre à jour la variable
                                    setButtonColor(currentMode);
                              }
                        } else if (type === 'track_objects') {
                              if (Array.isArray(data)) {
                                    console.log('Mise à jour de track_objects reçue via WebSocket:', data);
                                    currentTrackObjects = data;
                                    updateTrackObjectsCheckboxes();
                              }
                        } else if (type === 'track_objects_list') {
                              if (Array.isArray(data)) {
                                    console.log('Mise à jour de track_objects_list reçue via WebSocket:', data);
                                    currentTrackObjectsList = data;
                                    renderCheckboxes(currentTrackObjectsList, currentTrackObjects);
                              }
                        } else {
                              console.warn('Type de message WebSocket inconnu:', type);
                        }
                  } catch (e) {
                        console.error('Erreur lors du traitement du message WebSocket:', e);
                  }
            };

            socket.onclose = function (event) {
                  console.log('WebSocket fermé. Tentative de reconnexion dans 5 secondes...');
                  setTimeout(initializeWebSocket, 5000);
            };

            socket.onerror = function (error) {
                  console.error('Erreur WebSocket:', error);
                  socket.close();
            };
      }

      // Initialiser la connexion WebSocket au chargement de la page
      initializeWebSocket();

      // Fonction pour mettre à jour le mode sur le serveur via HTTP POST
      function updateMode(newMode) {
            return fetch('/camera_mode', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ mode: newMode })
            })
                  .then(response => response.json())
                  .then(data => {
                        return data.mode;
                  });
      }

      // Mettre la couleur du bouton en fonction du mode
      function setButtonColor(modeValue) {
            const index = modeValue % 3; // 0, 1 ou 2
            modeButton.style.backgroundColor = modeColors[index];
      }

      // Récupération initiale du mode au chargement de la page via HTTP
      fetch('/camera_mode')
            .then(modeResponse => modeResponse.json())
            .then(modeData => {
                  currentMode = modeData.mode;
                  setButtonColor(currentMode);
            })
            .catch(err => console.error('Erreur lors de la récupération initiale du mode:', err));

      // Gérer le clic sur le bouton
      modeButton.addEventListener('click', () => {
            let newMode = (currentMode + 1) % 3;
            updateMode(newMode)
                  .then(updatedMode => {
                        // currentMode sera mis à jour via le message WebSocket
                        // mais vous pouvez également le mettre à jour ici pour une meilleure UX
                        currentMode = updatedMode;
                        setButtonColor(updatedMode);
                  })
                  .catch(err => console.error('Erreur lors de la mise à jour du mode:', err));
      });

      // ----- PARTIE 2 : Gestion dynamique de track_objects -----

      // 2.1) Récupérer la liste track_objects_list existante
      function fetchTrackObjectsList() {
            return fetch('/track_objects_list')
                  .then(response => response.json())
                  .then(data => data.track_objects_list || [])
                  .catch(err => { console.error(err); return []; });
      }

      // 2.2) Récupérer la liste track_objects existante
      function fetchTrackObjects() {
            return fetch('/track_objects')
                  .then(response => response.json())
                  .then(data => data.track_objects || [])
                  .catch(err => { console.error(err); return []; });
      }

      // 2.3) Mettre à jour la liste track_objects sur le serveur
      function updateTrackObjects(objectsList) {
            return fetch('/track_objects', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ track_objects: objectsList })
            })
                  .then(response => response.json())
                  .catch(err => { console.error(err); return {}; });
      }

      // 2.4) Initialiser les checkboxes dynamiquement
      function initializeTrackObjects() {
            Promise.all([fetchTrackObjectsList(), fetchTrackObjects()])
                  .then(([trackObjectsList, trackObjects]) => {
                        currentTrackObjectsList = trackObjectsList;
                        currentTrackObjects = trackObjects;
                        renderCheckboxes(currentTrackObjectsList, currentTrackObjects);
                  })
                  .catch(err => console.error(err));
      }

      // Fonction pour rendre les checkboxes
      function renderCheckboxes(trackObjectsList, trackObjects) {
            // Vider le conteneur existant
            trackObjectsContainer.innerHTML = '<h3>Track Objects</h3>';

            trackObjectsList.forEach(obj => {
                  // Créer un label
                  const label = document.createElement('label');
                  label.style.display = 'block'; // Afficher chaque checkbox sur une nouvelle ligne

                  // Créer l'input checkbox
                  const checkbox = document.createElement('input');
                  checkbox.type = 'checkbox';
                  checkbox.value = obj;
                  checkbox.id = `${obj}-checkbox`;
                  checkbox.checked = trackObjects.includes(obj);

                  // Ajouter un écouteur d'événement
                  checkbox.addEventListener('change', handleCheckboxChange);

                  // Ajouter l'input au label
                  label.appendChild(checkbox);

                  // Ajouter le texte au label
                  const labelText = document.createTextNode(` ${obj}`);
                  label.appendChild(labelText);

                  // Ajouter le label au conteneur
                  trackObjectsContainer.appendChild(label);
            });
      }

      // Fonction pour mettre à jour les checkboxes en fonction de track_objects
      function updateTrackObjectsCheckboxes() {
            const checkboxes = trackObjectsContainer.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(cb => {
                  cb.checked = currentTrackObjects.includes(cb.value);
            });
      }

      // 2.5) Gérer les changements des checkboxes
      function handleCheckboxChange() {
            // Récupérer tous les checkboxes
            const checkboxes = trackObjectsContainer.querySelectorAll('input[type="checkbox"]');
            const newList = [];
            checkboxes.forEach(cb => {
                  if (cb.checked) newList.push(cb.value);
            });

            // Mettre à jour les track_objects sur le serveur
            updateTrackObjects(newList)
                  .then(data => {
                        console.log('track_objects mis à jour:', data.track_objects);
                  })
                  .catch(err => console.error('Erreur lors de la mise à jour de track_objects:', err));
      }

      // Initialiser les checkboxes au chargement de la page
      initializeTrackObjects();

      // Gérer les mises à jour des track_objects via WebSocket
      // (Déjà géré dans socket.onmessage)

      // Configuration du streaming HLS
      if (Hls.isSupported()) {
            const hls = new Hls();
            hls.loadSource(videoSrc);
            hls.attachMedia(video);
            hls.on(Hls.Events.MANIFEST_PARSED, function () {
                  video.play();
            });
      } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
            video.src = videoSrc;
            video.addEventListener('loadedmetadata', function () {
                  video.play();
            });
      }
</script>
{% endblock %}