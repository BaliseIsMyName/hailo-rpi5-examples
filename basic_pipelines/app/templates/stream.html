{% extends "base.html" %}

{% block title %}Stream - WetTheCat{% endblock %}

{% block content %}
<div class="container stream-page">
      <h2>LIVE</h2>
      <video id="video" controls autoplay muted></video>

      <!-- Bouton pour changer le mode -->
      <button id="mode-button" class="mode-button" style="background-color: red;">   
      </button>
      <div class="checkbox-container" id="track-objects-container" style="margin-top: 20px;">
            <h3>Track Objects</h3>
            <!-- Les checkboxes seront générées dynamiquement ici -->
      </div>
</div>

<!-- Inclure hls.js depuis un CDN -->
<script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
<script>
      const video = document.getElementById('video');
      const videoSrc = "{{ stream_url }}";
      const modeButton = document.getElementById('mode-button');
      const catCheckbox = document.getElementById('cat-checkbox');
      const trackObjectsContainer = document.getElementById('track-objects-container');

      // Couleurs associées aux différents modes (0, 1, 2)
      const modeColors = ['#ec6152', '#52ec97', '#5271ec'];

      // Stockage local des track_objects_list pour détecter les changements
      let currentTrackObjectsList = [];

      // Fonction pour récupérer le mode sur le serveur
      function fetchMode() {
            return fetch('/camera_mode')
                  .then(response => response.json())
                  .then(data => {
                        return data.mode;
                  });
      }

      // Fonction pour mettre à jour le mode sur le serveur
      function updateMode(newMode) {
            return fetch('/camera_mode', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ mode: newMode })
            })
                  .then(response => response.json())
                  .then(data => {
                        return data.mode;
                  });
      }

      // Mettre la couleur du bouton en fonction du mode
      function setButtonColor(modeValue) {
            const index = modeValue % 3; // 0, 1 ou 2
            modeButton.style.backgroundColor = modeColors[index];
      }

      // Récupération initiale du mode au chargement de la page
      fetchMode()
            .then(mode => {
                  setButtonColor(mode);
            })
            .catch(err => console.error(err));

      // Vérifier régulièrement si le mode a changé ailleurs
      setInterval(() => {
            fetchMode()
                  .then(mode => {
                        setButtonColor(mode);
                  })
                  .catch(err => console.error(err));
      }, 5000);  // toutes les 5 secondes

      // Gérer le clic sur le bouton
      modeButton.addEventListener('click', () => {
            fetchMode()
                  .then(mode => {
                        // Incrémente le mode (0 -> 1 -> 2 -> 0)
                        let newMode = (mode + 1) % 3;
                        return updateMode(newMode);
                  })
                  .then(updatedMode => {
                        setButtonColor(updatedMode);
                  })
                  .catch(err => console.error(err));
      });

      // ----- PARTIE 2 : Gestion dynamique de track_objects -----

      // 2.1) Récupérer la liste track_objects_list existante
      function fetchTrackObjectsList() {
            return fetch('/track_objects_list')
                  .then(response => response.json())
                  .then(data => data.track_objects_list || [])
                  .catch(err => { console.error(err); return []; });
      }

      // 2.2) Récupérer la liste track_objects existante
      function fetchTrackObjects() {
            return fetch('/track_objects')
                  .then(response => response.json())
                  .then(data => data.track_objects || [])
                  .catch(err => { console.error(err); return []; });
      }

      // 2.3) Mettre à jour la liste track_objects sur le serveur
      function updateTrackObjects(objectsList) {
            return fetch('/track_objects', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ track_objects: objectsList })
            })
                  .then(response => response.json())
                  .catch(err => { console.error(err); return {}; });
      }

      // 2.4) Initialiser les checkboxes dynamiquement
      function initializeTrackObjects() {
            Promise.all([fetchTrackObjectsList(), fetchTrackObjects()])
                  .then(([trackObjectsList, trackObjects]) => {
                        // Vérifier si la liste a changé
                        if (JSON.stringify(trackObjectsList) !== JSON.stringify(currentTrackObjectsList)) {
                              currentTrackObjectsList = trackObjectsList;
                              renderCheckboxes(trackObjectsList, trackObjects);
                        }
                  })
                  .catch(err => console.error(err));
      }

      // Fonction pour rendre les checkboxes
      function renderCheckboxes(trackObjectsList, trackObjects) {
            // Vider le conteneur existant
            trackObjectsContainer.innerHTML = '<h3>Track Objects</h3>';

            trackObjectsList.forEach(obj => {
                  // Créer un label
                  const label = document.createElement('label');
                  label.style.display = 'block'; // Afficher chaque checkbox sur une nouvelle ligne

                  // Créer l'input checkbox
                  const checkbox = document.createElement('input');
                  checkbox.type = 'checkbox';
                  checkbox.value = obj;
                  checkbox.id = `${obj}-checkbox`;
                  checkbox.checked = trackObjects.includes(obj);

                  // Ajouter un écouteur d'événement
                  checkbox.addEventListener('change', handleCheckboxChange);

                  // Ajouter l'input au label
                  label.appendChild(checkbox);

                  // Ajouter le texte au label
                  const labelText = document.createTextNode(` ${obj}`);
                  label.appendChild(labelText);

                  // Ajouter le label au conteneur
                  trackObjectsContainer.appendChild(label);
            });
      }

      // 2.5) Gérer les changements des checkboxes
      function handleCheckboxChange() {
            // Récupérer tous les checkboxes
            const checkboxes = trackObjectsContainer.querySelectorAll('input[type="checkbox"]');
            const newList = [];
            checkboxes.forEach(cb => {
                  if (cb.checked) newList.push(cb.value);
            });

            // Mettre à jour les track_objects sur le serveur
            updateTrackObjects(newList)
                  .then(data => {
                        console.log('track_objects mis à jour:', data.track_objects);
                  })
                  .catch(err => console.error(err));
      }

      // Initialiser les checkboxes au chargement de la page
      initializeTrackObjects();

      // Vérifier régulièrement si track_objects_list a changé
      setInterval(() => {
            initializeTrackObjects();
      }, 10000); // toutes les 10 secondes
            
      // Configuration du streaming HLS
      if (Hls.isSupported()) {
            const hls = new Hls();
            hls.loadSource(videoSrc);
            hls.attachMedia(video);
            hls.on(Hls.Events.MANIFEST_PARSED, function () {
                  video.play();
            });
      } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
            video.src = videoSrc;
            video.addEventListener('loadedmetadata', function () {
                  video.play();
            });
      }
</script>
{% endblock %}